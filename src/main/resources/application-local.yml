spring:
  # multipart upload파일 용량설정
  # default : 1MB
  servlet:
    multipart:
      enabled: true   # Multipart 파일 업로드 활성화
      max-file-size: 10MB   # 업로드 가능한 파일 크기 제한
      max-request-size: 10MB  # 요청 전체 크기 제한
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: ${MY_SQL_URL}
    username: ${MY_SQL_USERNAME}
    password: ${MY_SQL_SECRET}

  logging:
    level:
      org.springframework.messaging.simp: TRACE
      org.springframework.messaging.simp.stomp: TRACE
      org.springframework.web.socket: TRACE
  # swagger
  mvc:
    pathmatch:
      matching-strategy: ant_path_matcher

  jpa:
    # 데이터베이스 플랫폼을 지정
    database-platform: org.hibernate.dialect.MySQL8Dialect
    # JPA Open EntityManager in View 패턴을 활성화 또는 비활성화
    # false하는 경우 : 트래픽이 중요할 때
    # true하는 경우 : 트래픽보다는 성능을 우선하고 싶을 때 (주로 admin - 어드민의 경우 트래픽이 별로 없기 때문)
    open-in-view: false
    hibernate:
      # Hibernate가 데이터베이스 스키마를 자동으로 생성 또는 갱신할 때 사용
      ddl-auto: create
    properties:
      hibernate:
        # SQL 쿼리를 보기 쉽게 형식화할지 여부를 지정
        format_sql: true
        # LAZY 로딩 시 기본적으로 사용되는 배치 크기를 설정
        # fetch join 사용시 최적화
        default_batch_fetch_size: 100
        # SQL 쿼리에 주석을 추가할지 여부를 지정
        use_sql_comments: true

  data:
    web:
      pageable:
        default-page-size: 10
        max-page-size: 2000
        one-indexed-parameters: true
  security:
    oauth2:
      client:
        registration:
            kakao :
              client-name: kakao #서비스명
              client-id: ${KAKAO_ID} #서비스에서 발급 받은 아이디
              client-secret: ${KAKAO_SECERET} #서비스에서 발급 받은 비밀번호
              redirect-uri: ${KAKAO_URI} #서비스에 등록한 우리쪽 로그인 성공 URI         # 이걸 로컬과 운영 다르게 해야한다.
              authorization-grant-type: authorization_code
              client-authentication-method: client_secret_post
              scope:
                - profile_nickname
                - profile_image
            google:
              client-name: google
              client-id: ${GOOGLE_ID} #구글에서 발급받은 클라이언트 ID
              client-secret: ${GOOGLE_SECERET} #구글에서 발급받은 클라이언트 시크릿
              redirect-uri: ${GOOGLE_URI} # 이걸 로컬과 운영 다르게 해야한다.
              authorization-grant-type: authorization_code
              client-authentication-method: client_secret_post
              scope:
                - profile
                - email
        provider: # 구글 등등 전세계적 유명 서비스는 아래 것 넣어줌 (네이버, 카카오 같은건 넣어줘)
          kakao:
            authorization-uri: https://kauth.kakao.com/oauth/authorize #서비스 로그인 창 주소
            token-uri: https://kauth.kakao.com/oauth/token #토큰 발급 서버 주소
            user-info-uri: https://kapi.kakao.com/v2/user/me #사용자 정보 획득 주소
            user-name-attribute: id #응답 데이터 변수
  jwt:
    secret: ${JWT_SECRET}

cloud:
  aws:
    credentials:
      access-key: ${S3_ACCESS}
      secret-key: ${S3_SECRET}
    region:
      static: ap-northeast-2
    s3:
      bucket: ${S3_BUCKET}
      endpoint: https://s3.ap-northeast-2.amazonaws.com
    stack:
      auto: false




logging:
  level:
    org:
      # Hibernate 라이브러리에 속한 org.hibernate.SQL 패키지의 클래스들에 대한 로그 레벨을 설정합니다.
      # 특정 라이브러리나 패키지에 대한 로그 레벨을 따로 조정하고자 할 때 사용됩니다.
      # Hibernate의 SQL 쿼리를 자세히 보고 싶을 때 유용합니다.
      hibernate:
        SQL: debug
    # 이 설정은 애플리케이션 전반적인 로그 레벨을 설정합니다.
    # root는 로깅의 루트 패키지를 나타냅니다.
    # 따라서 root 패키지 이하의 모든 클래스들에 대한 로그 레벨이 debug로 설정됩니다.
    # 이는 애플리케이션 전체에 적용되는 설정이기 때문에 상세한 로그가 많이 생성될 수 있습니다.

springdoc:
  swagger-ui:
    path: /swagger-ui.html


